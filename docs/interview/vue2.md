---
title: Vue2相关面试题
outline: deep
---

# Vue2 相关面试题

## 1. `Vue`响应式数据的理解

Vue2 的响应式系统可以监控数据的修改和获取操作。针对对象格式，会给每个对象的属性进行劫持，使用 `Object.defineProperty` 实现。

从源码层面分析，实现流程为：`initData` -> `observe` -> `defineReactive`。内部对所有属性都进行了重写（这也是 Vue2 响应式系统的性能问题所在）。系统会递归给对象的属性增加 `getter` 和 `setter`。

使用 Vue2 时，如果数据层级过深，需要考虑以下优化方案：

- 非响应式数据不要放在 `data` 中
- 属性取值时避免多次重复取值
- data 中的对象可以考虑使用 `Object.freeze()` 冻结对象，阻止其转换为响应式

## 2.`Vue`中如何检测数组变化

Vue2 中检测数组的变化并没有采取 `defineProperty`，因为修改索引的情况不多(如果直接使用 `defineProperty` 会浪费大量性能)。采用重写数组的方法来实现(函数劫持)。

实现流程：`initData` -> `observe` -> 对我们传入的数组进行原型链修改，后续调用的方法都是重写后的方法 -> 对数组中的每个对象也再次进行代理

**修改数组的索引、数组的长度是无法监控的，不会触发视图更新**

## 3.`Vue`中如何进行依赖收集

所谓的依赖收集就是观察者模式。被观察者指代的是数据(`dep`)，观察者(`watcher`，有三种`watcher`分别是渲染`watcher`、计算属性`watcher`、用户`watcher`)。

一个`watcher`中可能对应对个数据。`watcher`中还需要保存`dep`(重新渲染时可以让属性重新记录`watcher`)，计算属性也会用到。

`watcher`和 `dep`的关系是多对多的关系，一个 `dep`对应多个 `watcher`，一个 `watcher`对应多个 `watcher`。默认渲染时会进行依赖手机(会触发 `getter`方法)，数据更新了就找到属性对应的 `watcher`去触发更新。

## 4.`Vue`中模版编译原理

用户传递的是 `template` 属性, 我们需要将这个 `template` 编译成 `render` 函数

- `template` -> `ast` 语法树
- 对语法树进行标记(标记的是静态节点)
- 将 `ast` 语法树 生成 `render` 函数

最终每次渲染可以调用 `render` 函数返回对应的虚拟节点(递归是先子后父)。

## 5.`Vue`生命周期钩子是如何实现的

内部利用了一个 **发布订阅模式**，将用户写的钩子维护成一个数组，后续一次调用 callHook 执行。主要是通过 `mergeOptions` 合并钩子。

## 6.`Vue`的生命周期方法有哪些？一般是在哪一步发送请求及原因

一般在 `mounted`

## 7.`Vue.mixin`的使用场景和原理

可以通过 `Vue.mixin` 来实现逻辑的复用，问题在于数据来源不明确。声明的时候可能会导致命名冲突。高阶组件，`Vue3` 采用的就是 `compositionApi` 解决了复用问题

## 8.`Vue`组件 `data`为什么必须是个函数？

原因就在于相对于根实例而言，`new Vue` 组件是通过同一个构造函数多次创建实例，如果是同一个对象的话，那么数据会被互相影响。每个组件都应该是独立的，那么每次都调用 `data` 会返回一个新对象。

## 9.`nextTick`在哪里使用? 原理是？

## 高级原理

> 更多面试题将陆续添加...
